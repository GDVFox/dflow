# runtime

Wrapper для запуска бинарных файлов действий.

## Действия

Действия создает пользователь, реализуя необходимую бизнес-логику. Для обмена данными действия используют [стандартные потоки][Standard Streams]:

* STDIN: используется для получения входящих сообщений.
* STDOUT: используется для записи исходящих сообщений.
* STDERR: используется для вывода ошибок, а также логирования.

По своей роли действия делятся на 3 группы:

* Источники данных: порождают поток данных, т.е. не имеют входных потоков. На практике это означает, что из STDIN ничего не читается. Если выходных потоков несколько, то данные копируются всем получателям одновременно.
* Обработчики данных: обрабатывают данные, при этом данные из нескольких входов сливаются в один в порядке их получения сервером. Используют и STDIN, и STDOUT. Правило копирования STDOUT аналогично источнику данных.
* Стоки: собирают данные, сливают несколько входных потоков в один аналогично обработчику.

## Гарантия доставки сообщений

DFlow обеспечивает доставку сообщений с гарантией *at-least-once*, что означает, что в случае отказа, некоторые сообщения могут дублироваться, но никогда не будут пропущены.  
*Отсюда следует, что действия должны быть идемпотентными.*

## Создание действия

Действие создается с помощью библиотеки, специализированной для языка программирования. Библиотеки находятся в директории `lib`.

Рассмотрим написание действия на примере фильтра, который находится в `examples/simplepipe/filter`:

```go
var mod int

func init() {
    // Действия можно конфигурировать с помощью флагов и переменных окружения. В данном случае используем флаг --mod для задания делителя.
	flag.IntVar(&mod, "mod", 1, "passes messages that are multiples of mod")
}

func main() {
	flag.Parse()

	for {
        // Загружаем очередное сообщение из входного потока
		data, err := actionlib.ReadMessage()
		if err != nil {
            // Логирует ошибку и продолжает обработку уже нового сообщения.
			actionlib.WriteError(err)
            continue
		} 

        // Получаем переданное число, в этом
        // месте может быть использован любой пользовательский протокол, например JSON.
		number := binary.BigEndian.Uint32(data)
		if int(number)%mod != 0 {
            // В случае, если число не кратно mod
            // то пропускаем его.
            // Вызов AckMessage() означает, что сообщение считано,
            // но вывода не последует.
			actionlib.AckMessage()
			continue
		}

        // В противном случае записываем исходное сообщение без изменений.
		if err := actionlib.WriteMessage(data); err != nil {
            // Логирует ошибку и продолжает обработку уже нового сообщения.
			actionlib.WriteError(err)
            continue
		}
	}

}
```

Как видно из примера, действия будут представлять из себя read/write loop, который заключает в себе логику обработки сообщения.

## Конфигурация действий

Действия можно конфигурировать с помощью аргументов командной строки, в т.ч. и флагов, а также с помощью переменных окружения. Это значения задаются при описании схемы. Формат задания в схеме можно посмотреть [тут][].

[Standard Streams]: https://www.gnu.org/software/libc/manual/html_node/Standard-Streams.html
